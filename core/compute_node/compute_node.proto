syntax="proto3";
option cc_generic_services = true;

package compute_node_service;

message PageID{
    sint32 page_no = 1;
    int32 table_id = 2;
}

enum PendingType {
    XPending = 0;
    SPending = 1;
}

// 其他节点如果想对一个已经持有锁且冲突的页面加锁，则会向所有持有这个页面锁的节点发送PendingRequest消息
message PendingRequest {
    PageID page_id = 1;
    PendingType pending_type = 2;
};

message PendingResponse{}

message PushPageRequest{
    PageID page_id = 1; 
    bytes page_data = 2;
    sint32 src_node_id = 3; // 源节点ID, 用于标识是谁推送的页面
    sint32 dest_node_id = 4; // 目标节点ID, 用于标识页面推送的目标节点
}

message PushPageResponse{}

message NotifyPushPageRequest{
    PageID page_id = 1;
    repeated sint32 dest_node_ids = 2; // 多个目标节点
    sint32 src_node_id = 3; // 源节点ID（当前持有最新页的节点）
}

message NotifyPushPageResponse{}

message LockSuccessRequest{
    PageID page_id = 1;
    bool xlock_succeess = 2; // 1为排他锁加锁成功, 2为共享锁加锁成功
    sint32 newest_id = 3; // 最新的持有锁的节点ID
    bool push_or_pull = 4; // 是否需要推送页面数据, true表示推送页面数据, false表示不推送页面数据
}

message LockSuccessResponse{}

message GetPageRequest {
    PageID page_id = 1;
};

message GetPageResponse {
    bytes page_data = 1;
    bool need_to_storage = 2;
};

message DTX{
    uint64 seed = 1;
    uint64 tx_type = 2;
    uint64 is_partitioned = 3;
    uint64 dtx_id = 5;  
}

message TransferDTXRequest{
    sint32 src_node_id = 1;
    sint32 dst_node_id = 2;
    uint64 batch_id = 3;
    repeated DTX dtxs = 4;
}

message TransferDTXResponse{}

service ComputeNodeService {
    rpc Pending(PendingRequest) returns (PendingResponse);
    rpc GetPage(GetPageRequest) returns (GetPageResponse);
    rpc LockSuccess(LockSuccessRequest) returns(LockSuccessResponse);
    rpc TransferDTX(TransferDTXRequest) returns (TransferDTXResponse);
    rpc PushPage(PushPageRequest) returns (PushPageResponse);
    rpc NotifyPushPage(NotifyPushPageRequest) returns (NotifyPushPageResponse);
};